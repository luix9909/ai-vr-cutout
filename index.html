<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <title>AR People Room - Passthrough Gallery</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- A-Frame & dependencies -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component@^5.0.0/dist/aframe-event-set-component.min.js"></script>

    <style>
        /* =============================
           RESET & BASE
           ============================= */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #050505;
            color: #f3f3f3;
            direction: rtl;
        }

        body {
            display: flex;
            flex-direction: column;
        }

        /* =============================
           APP SHELL
           ============================= */
        #app {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* =============================
           TOP BAR
           ============================= */
        .top-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 64px;
            background: linear-gradient(to right, rgba(0,0,0,0.9), rgba(10,10,10,0.9));
            border-bottom: 1px solid rgba(255,255,255,0.06);
            display: flex;
            align-items: center;
            padding: 0 18px;
            z-index: 50;
            backdrop-filter: blur(12px);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brand-logo {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ffffff, #333333);
            box-shadow: 0 0 14px rgba(255,255,255,0.4);
        }

        .brand-text {
            display: flex;
            flex-direction: column;
        }

        .brand-title {
            font-size: 17px;
            font-weight: 700;
            letter-spacing: 0.03em;
        }

        .brand-sub {
            font-size: 11px;
            opacity: 0.7;
        }

        .top-bar-spacer {
            flex: 1;
        }

        .top-bar-buttons {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn {
            border: none;
            outline: none;
            border-radius: 999px;
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: background 0.25s ease, transform 0.15s ease, box-shadow 0.25s ease, border-color 0.25s ease;
        }

        .btn-primary {
            background: #ffffff;
            color: #000000;
            box-shadow: 0 0 12px rgba(255,255,255,0.35);
        }

        .btn-primary:hover {
            background: #f0f0f0;
            transform: translateY(-1px);
            box-shadow: 0 0 18px rgba(255,255,255,0.55);
        }

        .btn-ghost {
            background: rgba(255,255,255,0.04);
            color: #f3f3f3;
            border: 1px solid rgba(255,255,255,0.15);
        }

        .btn-ghost:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.25);
            transform: translateY(-1px);
        }

        .btn-icon {
            width: 32px;
            height: 32px;
            border-radius: 999px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #f3f3f3;
            transition: background 0.25s ease, transform 0.15s ease, border-color 0.25s ease;
        }

        .btn-icon:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        .btn-icon svg {
            width: 16px;
            height: 16px;
        }

        /* =============================
           STATUS / TOAST
           ============================= */
        #status-bar {
            position: absolute;
            top: 72px;
            left: 50%;
            transform: translateX(-50%);
            min-width: 240px;
            max-width: 520px;
            background: rgba(0,0,0,0.85);
            border-radius: 999px;
            padding: 8px 18px;
            z-index: 40;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 0 14px rgba(0,0,0,0.8);
            font-size: 13px;
            border: 1px solid rgba(255,255,255,0.08);
            backdrop-filter: blur(10px);
        }

        #status-dot {
            width: 9px;
            height: 9px;
            border-radius: 50%;
            background: #18e298;
            box-shadow: 0 0 10px rgba(24,226,152,0.9);
        }

        #status-text {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* =============================
           BOTTOM PANEL
           ============================= */
        .bottom-panel {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            height: 160px;
            background: linear-gradient(to top, rgba(0,0,0,0.92), rgba(0,0,0,0.7), transparent);
            padding: 10px 14px 14px 14px;
            z-index: 40;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: none;
        }

        .bottom-panel-inner {
            max-width: 960px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }

        .bottom-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .bottom-title {
            font-size: 13px;
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .bottom-title span.icon {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            background: linear-gradient(135deg, #ffffff, #888888);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-size: 12px;
            font-weight: 700;
        }

        .bottom-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
        }

        .file-input-button {
            padding: 7px 14px;
            border-radius: 999px;
            background: rgba(255,255,255,0.06);
            border: 1px dashed rgba(255,255,255,0.25);
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .file-input-button:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.45);
        }

        .file-input-button small {
            opacity: 0.75;
        }

        /* Thumbnail scroller */
        .thumb-strip {
            margin-top: 3px;
            padding: 4px 0;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .thumb-strip-label {
            font-size: 11px;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .thumb-strip-label-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ffffff;
            opacity: 0.7;
        }

        .thumb-strip-row {
            margin-top: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
            overflow-x: auto;
            padding-bottom: 4px;
        }

        .thumb-item {
            flex: 0 0 auto;
            width: 80px;
            height: 110px;
            border-radius: 10px;
            background: radial-gradient(circle at 30% 20%, #ffffff, #444444);
            border: 1px solid rgba(255,255,255,0.4);
            box-shadow: 0 0 13px rgba(0,0,0,0.9);
            overflow: hidden;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }

        .thumb-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 16px rgba(255,255,255,0.24);
            border-color: rgba(255,255,255,0.9);
        }

        .thumb-item img,
        .thumb-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .thumb-type-tag {
            position: absolute;
            bottom: 4px;
            left: 4px;
            padding: 2px 5px;
            border-radius: 999px;
            background: rgba(0,0,0,0.75);
            font-size: 9px;
        }

        .thumb-delete {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 18px;
            height: 18px;
            border-radius: 999px;
            background: rgba(0,0,0,0.78);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            cursor: pointer;
        }

        .thumb-delete:hover {
            background: rgba(0,0,0,0.95);
        }

        /* =============================
           SIDEBAR (LIST OF PLACED OBJECTS)
           ============================= */
        .side-panel {
            position: absolute;
            top: 72px;
            right: 12px;
            width: 224px;
            bottom: 170px;
            border-radius: 15px;
            background: radial-gradient(circle at 0 0, rgba(255,255,255,0.06), rgba(0,0,0,0.95));
            box-shadow: 0 0 20px rgba(0,0,0,0.85);
            z-index: 30;
            padding: 10px 10px 10px 12px;
            border: 1px solid rgba(255,255,255,0.12);
            display: flex;
            flex-direction: column;
            gap: 8px;
            backdrop-filter: blur(12px);
        }

        .side-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
        }

        .side-header span {
            font-weight: 600;
        }

        .side-header small {
            opacity: 0.65;
        }

        .side-list {
            flex: 1;
            overflow-y: auto;
            padding-right: 4px;
            padding-top: 3px;
        }

        .side-item {
            border-radius: 9px;
            padding: 6px 7px;
            background: rgba(0,0,0,0.75);
            display: flex;
            align-items: center;
            gap: 7px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
        }

        .side-item:hover {
            background: rgba(255,255,255,0.06);
            transform: translateY(-1px);
        }

        .side-thumb {
            width: 38px;
            height: 38px;
            border-radius: 7px;
            overflow: hidden;
            background: #222;
        }

        .side-thumb img,
        .side-thumb video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .side-meta {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
        }

        .side-meta-title {
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .side-meta-sub {
            font-size: 10px;
            opacity: 0.6;
        }

        .side-actions {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .pill-btn {
            border: none;
            font-size: 9px;
            padding: 3px 6px;
            border-radius: 999px;
            cursor: pointer;
            background: rgba(255,255,255,0.08);
            color: #f3f3f3;
            transition: background 0.2s ease;
        }

        .pill-btn:hover {
            background: rgba(255,255,255,0.19);
        }

        .pill-btn-danger {
            background: rgba(255,50,50,0.13);
            color: #ffcccc;
        }

        .pill-btn-danger:hover {
            background: rgba(255,60,60,0.32);
        }

        /* =============================
           A-SCENE CONTAINER
           ============================= */
        .scene-wrapper {
            position: absolute;
            inset: 0;
            z-index: 10;
        }

        a-scene {
            width: 100%;
            height: 100%;
        }

        /* Hide default VR button bubble */
        .a-enter-vr-button,
        .a-enter-vr {
            display: none !important;
        }

        /* =============================
           RESPONSIVE
           ============================= */
        @media (max-width: 768px) {
            .top-bar {
                height: 58px;
                padding-inline: 10px;
            }

            .bottom-panel {
                height: 180px;
            }

            .side-panel {
                display: none;
            }

            #status-bar {
                top: 62px;
            }
        }
    </style>
</head>
<body>
<div id="app">

    <!-- Top Bar -->
    <header class="top-bar">
        <div class="brand">
            <div class="brand-logo"></div>
            <div class="brand-text">
                <div class="brand-title">AR People Room</div>
                <div class="brand-sub">ÿ∂ÿπ ÿµŸàÿ±ŸÉ ÿ£Ÿà ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÅŸä ÿ∫ÿ±ŸÅÿ™ŸÉ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ AR</div>
            </div>
        </div>
        <div class="top-bar-spacer"></div>
        <div class="top-bar-buttons">
            <button id="btnEnterAR" class="btn btn-primary">
                üöÄ ÿ™ÿ¥ÿ∫ŸäŸÑ Ÿàÿ∂ÿπ AR
            </button>
            <button id="btnResetAll" class="btn btn-ghost">
                üóëÔ∏è ŸÖÿ≥ÿ≠ ŸÉŸÑ ÿßŸÑÿπŸÜÿßÿµÿ±
            </button>
            <button id="btnHelp" class="btn-icon" title="ŸÖÿ≥ÿßÿπÿØÿ©">
                ?
            </button>
        </div>
    </header>

    <!-- Status Bar -->
    <div id="status-bar">
        <div id="status-dot"></div>
        <div id="status-text">ÿ¨ÿßŸáÿ≤ÿå ÿßÿ±ŸÅÿπ ÿµŸàÿ±ÿ© ÿ£Ÿà ŸÅŸäÿØŸäŸà ÿ´ŸÖ ÿßÿØÿÆŸÑ Ÿàÿ∂ÿπ AR.</div>
    </div>

    <!-- Side Panel: Placed Objects -->
    <aside class="side-panel" id="sidePanel">
        <div class="side-header">
            <span>ÿßŸÑÿπŸÜÿßÿµÿ± ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©</span>
            <small id="sideCount">0 ÿπŸÜÿµÿ±</small>
        </div>
        <div class="side-list" id="sideList">
            <!-- items injected here -->
        </div>
    </aside>

    <!-- Bottom Panel: Uploads & Thumbnails -->
    <section class="bottom-panel">
        <div class="bottom-panel-inner">

            <div class="bottom-panel-header">
                <div class="bottom-title">
                    <span class="icon">AR</span>
                    ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿµŸàÿ± ŸàÿßŸÑŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©
                </div>
                <div class="bottom-actions">
                    <div class="file-input-wrapper">
                        <div class="file-input-button">
                            üì∑ ÿ•ÿ∂ÿßŸÅÿ© ÿµŸàÿ±
                            <small>(ŸäŸÖŸÉŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ PNG ÿ£Ÿà JPG)</small>
                        </div>
                        <input type="file" id="imageInput" accept="image/*" multiple>
                    </div>
                    <div class="file-input-wrapper">
                        <div class="file-input-button">
                            üé• ÿ•ÿ∂ÿßŸÅÿ© ŸÅŸäÿØŸäŸàŸáÿßÿ™
                            <small>(ŸäŸÅÿ∂ŸÑ ŸÖŸÇÿßÿ∑ÿπ ÿ¨ÿßŸáÿ≤ÿ© ŸÑŸÑÿ™ÿ¥ÿ∫ŸäŸÑ)</small>
                        </div>
                        <input type="file" id="videoInput" accept="video/*" multiple>
                    </div>
                </div>
            </div>

            <div class="thumb-strip">
                <div class="thumb-strip-label">
                    <div class="thumb-strip-label-dot"></div>
                    ÿßŸÑÿπŸÜÿßÿµÿ± ÿßŸÑŸÖÿ™ÿßÿ≠ÿ© ŸÑŸÑÿ•ÿ≥ŸÇÿßÿ∑ ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©
                </div>
                <div class="thumb-strip-row" id="thumbStrip">
                    <!-- thumbnails injected here -->
                </div>
            </div>

        </div>
    </section>

    <!-- Scene Wrapper -->
    <div class="scene-wrapper">
        <a-scene
                id="scene"
                renderer="alpha: true; antialias: true; colorManagement: true;"
                background="color: #000000"
                embedded
                vr-mode-ui="enabled: false"
                xr-mode-ui="enabled: true"
        >
            <a-assets id="assets"></a-assets>

            <!-- Lights (subtle, neutral) -->
            <a-entity light="type: ambient; intensity: 0.6; color: #ffffff"></a-entity>
            <a-entity light="type: directional; intensity: 0.9; color: #ffffff"
                      position="-1 3 -2"></a-entity>

            <!-- Camera Rig -->
            <a-entity id="rig">
                <a-camera
                        id="camera"
                        position="0 1.6 0"
                        wasd-controls-enabled="false"
                        look-controls="pointerLockEnabled: false">
                </a-camera>
            </a-entity>

            <!-- VR Controllers with laser pointers (will be visible in VR / AR controllers) -->
            <a-entity id="rightHand"
                      hand-controls="hand: right; handModelStyle: lowPoly; color: #39BB82"
                      laser-controls="hand: right"
                      raycaster="objects: .interactive; showLine: false">
            </a-entity>

            <a-entity id="leftHand"
                      hand-controls="hand: left; handModelStyle: lowPoly; color: #39BB82"
                      laser-controls="hand: left"
                      raycaster="objects: .interactive; showLine: false">
            </a-entity>

            <!-- A visible laser line (attached to each controller via JS for consistent look) -->

        </a-scene>
    </div>
</div>

<script>
    // ================================
    // GLOBAL VARIABLES & STATE
    // ================================
    const scene = document.getElementById('scene');
    const assets = document.getElementById('assets');

    const statusTextEl = document.getElementById('status-text');
    const statusDotEl = document.getElementById('status-dot');
    const thumbStrip = document.getElementById('thumbStrip');

    const imageInput = document.getElementById('imageInput');
    const videoInput = document.getElementById('videoInput');
    const btnEnterAR = document.getElementById('btnEnterAR');
    const btnResetAll = document.getElementById('btnResetAll');
    const btnHelp = document.getElementById('btnHelp');
    const sideList = document.getElementById('sideList');
    const sideCount = document.getElementById('sideCount');

    let isARSupported = false;
    let isARActive = false;

    // Uploaded media metadata
    const mediaLibrary = [];   // { id, type: 'image'|'video', url, name, assetEl }
    // Placed entities in room
    const placedItems = [];    // { id, mediaId, entity, type, name }

    // For placing objects via tap
    let selectedMediaForPlacement = null;

    // For controller interactions
    const controllers = {}; // right / left state

    // ================================
    // STATUS HELPER
    // ================================
    function setStatus(text, type = 'info') {
        statusTextEl.textContent = text;
        if (type === 'error') {
            statusDotEl.style.background = '#ff5252';
            statusDotEl.style.boxShadow = '0 0 8px rgba(255,82,82,0.9)';
        } else if (type === 'success') {
            statusDotEl.style.background = '#18e298';
            statusDotEl.style.boxShadow = '0 0 8px rgba(24,226,152,0.9)';
        } else {
            statusDotEl.style.background = '#f5f5f5';
            statusDotEl.style.boxShadow = '0 0 8px rgba(255,255,255,0.7)';
        }
    }

    // ================================
    // HELP MODAL (SIMPLE ALERT) - updated text (no mention of background removal)
    // ================================
    btnHelp.addEventListener('click', () => {
        alert(
            'ÿ∑ÿ±ŸäŸÇÿ© ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ:\n\n' +
            '1. ÿßÿ∂ÿ∫ÿ∑ "ÿ™ÿ¥ÿ∫ŸäŸÑ Ÿàÿ∂ÿπ AR" ŸÑÿ®ÿØÿ° ÿßŸÑÿπÿ±ÿ∂ (ÿ•ŸÜ ŸÉÿßŸÜ ÿ¨Ÿáÿßÿ≤ŸÉ ŸäÿØÿπŸÖ WebXR AR).\n' +
            '2. ÿßÿ±ŸÅÿπ ÿµŸàÿ± ÿ£Ÿà ŸÅŸäÿØŸäŸàŸáÿßÿ™ ŸÖŸÜ ÿßŸÑÿ£ÿ≥ŸÅŸÑ.\n' +
            '3. ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑŸÖÿµÿ∫ÿ±ÿ©ÿå ÿ´ŸÖ ÿßŸÑŸÖÿ≥ ÿ£Ÿà ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸäÿØ VR ŸÑŸÑÿ•ÿ¥ÿßÿ±ÿ© ŸàŸàÿ∂ÿπ ÿßŸÑÿπŸÜÿµÿ± ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©.\n' +
            '4. ŸÅŸä Ÿàÿ∂ÿπ VR/AR ŸäŸÖŸÉŸÜŸÉ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ŸäÿØ ÿßŸÑÿ™ÿ≠ŸÉŸÖ (ÿßŸÑŸÑŸäÿ≤ÿ±) ŸÑŸÑÿ•ŸÖÿ≥ÿßŸÉ Ÿàÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑÿπŸÜÿßÿµÿ± Ÿàÿ™ÿ±ŸÉŸáÿß ŸÅŸä ÿßŸÑŸÖŸÉÿßŸÜ ÿßŸÑŸÖÿ∑ŸÑŸàÿ®.\n\n' +
            'ŸÖŸÑÿßÿ≠ÿ∏ÿ©: ÿ≥Ÿäÿ™ÿ≠ÿ±ŸÉ ÿßŸÑŸÅŸäÿØŸäŸà ÿ™ŸÑŸÇÿßÿ¶ŸäÿßŸã ŸàŸäÿπŸÖŸÑ ŸÅŸä ÿ≠ŸÑŸÇÿ© (loop) ÿπŸÜÿØ Ÿàÿ∂ÿπŸá.'
        );
    });

    // ================================
    // AR SUPPORT DETECTION
    // ================================
    if (navigator.xr) {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
            isARSupported = supported;
            if (supported) {
                setStatus('ÿ¨Ÿáÿßÿ≤ŸÉ ŸäÿØÿπŸÖ WebXR ARÿå ÿßÿ∂ÿ∫ÿ∑ "ÿ™ÿ¥ÿ∫ŸäŸÑ Ÿàÿ∂ÿπ AR" ŸÑŸÑÿ®ÿØÿ°.', 'success');
            } else {
                setStatus('WebXR AR ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖ ÿ®ÿßŸÑŸÉÿßŸÖŸÑÿå ÿ≥Ÿäÿ™ŸÖ ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ¥ŸáÿØ ÿ®ÿØŸàŸÜ passthrough ŸÉÿßŸÖŸÑ.', 'error');
            }
        }).catch(() => {
            isARSupported = false;
            setStatus('ÿ™ÿπÿ∞ÿ± ŸÅÿ≠ÿµ ÿØÿπŸÖ ARÿå ŸÇÿØ ŸÑÿß ŸäÿπŸÖŸÑ Ÿàÿ∂ÿπ passthrough.', 'error');
        });
    } else {
        setStatus('ŸÖÿ™ÿµŸÅÿ≠ŸÉ ŸÑÿß ŸäÿØÿπŸÖ WebXRÿå ÿ≥Ÿäÿ™ŸÖ ÿπÿ±ÿ∂ ÿßŸÑÿ™ÿ¨ÿ±ÿ®ÿ© ŸÅŸä Ÿàÿ∂ÿπ 3D ÿπÿßÿØŸä.', 'error');
    }

    // ================================
    // ENTER AR - try to request immersive-ar session explicitly for passthrough
    // ================================
    btnEnterAR.addEventListener('click', async () => {
        if (!navigator.xr) {
            setStatus('ŸÖÿ™ÿµŸÅÿ≠ŸÉ ŸÑÿß ŸäÿØÿπŸÖ WebXR.', 'error');
            return;
        }

        // Try to request an immersive-ar session explicitly: best-effort to enable passthrough.
        try {
            if (isARSupported) {
                const sessionInit = {
                    optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking', 'layers', 'dom-overlay'],
                    // some browsers require DOM overlay origin, skip if not needed
                };
                const session = await navigator.xr.requestSession('immersive-ar', sessionInit).catch(err => {
                    console.warn('requestSession fallback', err);
                    return null;
                });

                if (session) {
                    // Attach the session to three.js / A-Frame renderer
                    if (scene.renderer && scene.renderer.xr) {
                        await scene.renderer.xr.setSession(session);
                        isARActive = true;
                        setStatus('Ÿàÿ∂ÿπ AR ŸÜÿ¥ÿ∑ (passthrough) ‚Äî ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ£ÿØŸàÿßÿ™ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ÿ£Ÿà ÿßŸÑŸÖÿ≥ ŸÑŸÑÿ¥ÿßÿ¥ÿ©.', 'success');
                        // Show controllers when session starts
                        enableControllersForSession();
                        return;
                    }
                }
            }

            // Fallback to A-Frame enterVR (it will pick immersive-ar when available)
            if (!scene.enterVR) {
                setStatus('ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿØÿÆŸàŸÑ ÿ•ŸÑŸâ Ÿàÿ∂ÿπ AR ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑŸÖÿ™ÿµŸÅÿ≠.', 'error');
                return;
            }
            await scene.enterVR();
            isARActive = true;
            setStatus('Ÿàÿ∂ÿπ AR/VR ŸÜÿ¥ÿ∑ÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÑŸäÿ≤ÿ± ŸÅŸä ŸäÿØ ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸÑŸÑÿ•ÿ¥ÿßÿ±ÿ© ŸàÿßŸÑÿ™ÿ≠ÿ±ŸäŸÉ.', 'success');
            enableControllersForSession();
        } catch (err) {
            console.error(err);
            setStatus('ÿ™ÿπÿ∞ÿ± ÿßŸÑÿØÿÆŸàŸÑ ÿ•ŸÑŸâ Ÿàÿ∂ÿπ ARÿå ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÑŸÖÿ™ÿµŸÅÿ≠/ÿßŸÑÿ£ÿ¨Ÿáÿ≤ÿ©.', 'error');
        }
    });

    // ================================
    // CONTROLLER + LASER + GRAB IMPLEMENTATION
    // - uses built-in raycaster on controllers to find .interactive elements
    // - supports grabbing (attach to controller) and release
    // - draws visible laser line from controller forward and always oriented
    // ================================
    function enableControllersForSession() {
        // create visible laser lines and setup event listeners
        ['right', 'left'].forEach(hand => {
            const el = document.getElementById(hand + 'Hand') || document.getElementById(hand + 'Hand'.replace('Hand', ''));
            // A-Frame entity IDs are rightHand / leftHand in markup
            const controllerEl = document.getElementById(hand + 'Hand') || document.getElementById(hand === 'right' ? 'rightHand' : 'leftHand');
            if (!controllerEl) return;

            // Ensure we only add once
            if (controllers[hand]) return;

            // Add a visible laser line (a thin cylinder or line)
            const laser = document.createElement('a-entity');
            laser.setAttribute('geometry', 'primitive: cylinder; radius: 0.002; height: 1');
            laser.setAttribute('material', 'color: #39BB82; opacity: 0.9; shader: flat');
            laser.setAttribute('position', '0 0 -0.5');
            laser.setAttribute('rotation', '90 0 0');
            laser.setAttribute('class', 'laser-visual');
            controllerEl.appendChild(laser);

            controllers[hand] = {
                el: controllerEl,
                hovered: null,
                grabbed: null
            };

            // Raycaster events: maintain hovered element (A-Frame raycaster emits events)
            controllerEl.addEventListener('raycaster-intersection', (evt) => {
                if (!evt.detail || !evt.detail.els || !evt.detail.els.length) return;
                // pick the closest intersected
                const nearest = evt.detail.els[0];
                controllers[hand].hovered = nearest;
                // visual hint: slightly scale
                if (nearest) nearest.object3D.scale.set(1.02, 1.02, 1.02);
            });

            controllerEl.addEventListener('raycaster-intersection-cleared', (evt) => {
                // clear hover
                if (controllers[hand].hovered) {
                    try {
                        controllers[hand].hovered.object3D.scale.set(1, 1, 1);
                    } catch (e) {}
                }
                controllers[hand].hovered = null;
            });

            // Grip / trigger down to grab
            controllerEl.addEventListener('triggerdown', (evt) => {
                const state = controllers[hand];
                const hovered = state.hovered;
                if (!hovered) {
                    setStatus('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿ•ÿ¥ÿßÿ±ÿ© ÿ•ŸÑŸâ ÿ£Ÿä ÿπŸÜÿµÿ±.', 'info');
                    return;
                }
                // grab if it's interactive
                if (hovered.classList.contains('interactive')) {
                    // store original world transform
                    state.grabbed = {
                        el: hovered,
                        originalParent: hovered.parentElement
                    };
                    // compute offset to keep relative pose
                    const handObj = controllerEl.object3D;
                    // make sure world matrices are updated
                    handObj.updateMatrixWorld();
                    hovered.object3D.updateMatrixWorld();

                    // compute inverse matrix to preserve local transform when reparenting
                    const inv = new THREE.Matrix4().copy(handObj.matrixWorld).invert();
                    hovered.object3D.applyMatrix4(inv);
                    // attach to controller
                    controllerEl.appendChild(hovered);
                    setStatus('ÿ™ŸÖ ÿßŸÑÿ•ŸÖÿ≥ÿßŸÉ ÿ®ÿßŸÑÿπŸÜÿµÿ±. ÿ≠ÿ±ŸëŸÉŸá ÿ´ŸÖ ÿßÿ±ŸÅÿπ ÿßŸÑÿ≤ŸÜÿßÿØ ŸÑŸÑÿ•ŸÅŸÑÿßÿ™.', 'info');

                    // if the grabbed item is a video, ensure it plays and loops
                    const mediaId = hovered.getAttribute && hovered.getAttribute('data-media-id');
                    if (mediaId) {
                        const media = mediaLibrary.find(m => m.id === mediaId);
                        if (media && media.type === 'video' && media.assetEl) {
                            try {
                                media.assetEl.loop = true;
                                media.assetEl.muted = false; // allow sound if desired (may be blocked until user gesture)
                                media.assetEl.play().catch(()=>{ /* autoplay may be blocked */ });
                            } catch (e) {}
                        }
                    }
                }
            });

            // Release on triggerup
            controllerEl.addEventListener('triggerup', (evt) => {
                const state = controllers[hand];
                if (!state.grabbed) {
                    return;
                }
                const grabbed = state.grabbed;
                const grabbedEl = grabbed.el;
                // compute world matrix of grabbed (since it's child of controller)
                grabbedEl.object3D.updateMatrixWorld();
                const worldMat = grabbedEl.object3D.matrixWorld.clone();

                // detach and reparent back to scene
                scene.appendChild(grabbedEl);

                // apply world matrix to new parent (scene)
                grabbedEl.object3D.matrix.copy(worldMat);
                grabbedEl.object3D.matrix.decompose(grabbedEl.object3D.position, grabbedEl.object3D.quaternion, grabbedEl.object3D.scale);
                grabbedEl.object3D.updateMatrixWorld(true);

                // clear state
                state.grabbed = null;
                setStatus('ÿ™ŸÖ ÿ•ŸÅŸÑÿßÿ™ ÿßŸÑÿπŸÜÿµÿ±.', 'success');
            });

            // keep laser oriented forward always when controller present
            controllerEl.addEventListener('controllerconnected', () => {
                // ensure visible laser exists and is long enough
                // Also listen for controller pose updates to keep laser aligned
            });
        });
    }

    // When session ends, cleanup controllers state
    if (navigator.xr) {
        navigator.xr.addEventListener && navigator.xr.addEventListener('end', () => {
            // simple cleanup
            Object.keys(controllers).forEach(h => {
                controllers[h] = null;
            });
        });
    }

    // ================================
    // HANDLE FILE UPLOADS (IMAGES & VIDEOS)
    // - ensure videos autoplay & loop reliably by calling play() after load and setting attributes
    // ================================
    function handleFiles(files, type) {
        if (!files || !files.length) return;
        Array.from(files).forEach((file) => {
            const url = URL.createObjectURL(file);
            const id = 'media_' + Date.now() + '_' + Math.random().toString(36).slice(2);
            const name = file.name || (type === 'image' ? 'ÿµŸàÿ±ÿ©' : 'ŸÅŸäÿØŸäŸà');

            // Create asset
            let assetEl;
            if (type === 'image') {
                assetEl = document.createElement('img');
                assetEl.setAttribute('id', id);
                assetEl.setAttribute('src', url);
                assetEl.crossOrigin = 'anonymous';
                assets.appendChild(assetEl);
            } else {
                assetEl = document.createElement('video');
                assetEl.setAttribute('id', id);
                assetEl.setAttribute('src', url);
                assetEl.setAttribute('loop', 'true');
                assetEl.setAttribute('muted', 'true');
                assetEl.setAttribute('playsinline', 'true');
                assetEl.crossOrigin = 'anonymous';
                assetEl.setAttribute('webkit-playsinline', 'true');
                assets.appendChild(assetEl);

                // Try to play as soon as metadata is loaded (user gesture may be required)
                assetEl.addEventListener('loadeddata', () => {
                    try { assetEl.play().catch(()=>{}); } catch(e) {}
                });
            }

            // Register in library
            mediaLibrary.push({
                id,
                type,
                url,
                name,
                assetEl
            });

            // Create thumbnail
            createThumb(id, type, url, name);
        });

        updateStatusAfterUpload();
    }

    function updateStatusAfterUpload() {
        if (!mediaLibrary.length) {
            setStatus('ÿßÿ±ŸÅÿπ ÿµŸàÿ±ÿ© ÿ£Ÿà ŸÅŸäÿØŸäŸà ŸÑŸÑÿ®ÿØÿ°.', 'info');
        } else {
            setStatus('ÿßÿÆÿ™ÿ± ÿπŸÜÿµÿ± ÿ´ŸÖ ÿßŸÑŸÖÿ≥ ÿ£Ÿà ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÑŸäÿ≤ÿ± ŸÅŸä ŸäÿØ VR ŸÑŸàÿ∂ÿπŸá ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©.', 'success');
        }
    }

    imageInput.addEventListener('change', (e) => {
        handleFiles(e.target.files, 'image');
        imageInput.value = '';
    });

    videoInput.addEventListener('change', (e) => {
        handleFiles(e.target.files, 'video');
        videoInput.value = '';
    });

    // ================================
    // CREATE THUMB UI
    // ================================
    function createThumb(id, type, url, name) {
        const item = document.createElement('div');
        item.className = 'thumb-item';
        item.dataset.id = id;

        let mediaEl;
        if (type === 'image') {
            mediaEl = document.createElement('img');
        } else {
            mediaEl = document.createElement('video');
            mediaEl.muted = true;
            mediaEl.loop = true;
            mediaEl.autoplay = true;
            mediaEl.playsInline = true;
        }
        mediaEl.src = url;
        item.appendChild(mediaEl);

        const tag = document.createElement('div');
        tag.className = 'thumb-type-tag';
        tag.textContent = type === 'image' ? 'ÿµŸàÿ±ÿ©' : 'ŸÅŸäÿØŸäŸà';
        item.appendChild(tag);

        const del = document.createElement('div');
        del.className = 'thumb-delete';
        del.textContent = '‚úï';
        del.addEventListener('click', (ev) => {
            ev.stopPropagation();
            deleteMediaFromLibrary(id);
        });
        item.appendChild(del);

        item.title = name;

        item.addEventListener('click', () => {
            selectedMediaForPlacement = id;
            setStatus('ÿßŸÑÿ¢ŸÜ ÿßŸÑŸÖÿ≥ ŸÅŸä ÿßŸÑŸÖŸÉÿßŸÜ ÿØÿßÿÆŸÑ AR ÿ£Ÿà ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑŸÑŸäÿ≤ÿ± ŸÑŸàÿ∂ÿπ ÿßŸÑÿπŸÜÿµÿ± ŸáŸÜÿßŸÉ.', 'info');
        });

        thumbStrip.appendChild(item);
    }

    function deleteMediaFromLibrary(id) {
        // Remove from library
        const idx = mediaLibrary.findIndex(m => m.id === id);
        if (idx >= 0) {
            // revoke url
            try { URL.revokeObjectURL(mediaLibrary[idx].url); } catch (e) {}
            // remove asset element
            const asset = document.getElementById(id);
            if (asset && asset.parentNode) {
                asset.parentNode.removeChild(asset);
            }
            mediaLibrary.splice(idx, 1);
        }

        // Remove thumbnails
        const thumbs = thumbStrip.querySelectorAll('.thumb-item');
        thumbs.forEach(t => {
            if (t.dataset.id === id) {
                t.remove();
            }
        });

        // Also remove placed items that use it
        const copy = [...placedItems];
        copy.forEach(pi => {
            if (pi.mediaId === id) {
                removePlacedItem(pi.id);
            }
        });

        updateSidePanel();
        updateStatusAfterUpload();
    }

    // ================================
    // PLACE OBJECT IN AR SCENE
    // - when user taps the scene or uses controller "select" event
    // - items are given class .interactive so controllers can raycast them
    // - set videos to loop and play when placed
    // ================================
    // Place on scene tap/click
    scene.addEventListener('click', (evt) => {
        if (!selectedMediaForPlacement) return;

        const media = mediaLibrary.find(m => m.id === selectedMediaForPlacement);
        if (!media) {
            setStatus('ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑŸÖÿ≠ÿØÿØ ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿå ÿ£ÿπÿØ ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ±.', 'error');
            selectedMediaForPlacement = null;
            return;
        }

        // Place at 2m in front of camera at head height
        const cameraEl = document.getElementById('camera');
        if (!cameraEl) return;

        const camObj = cameraEl.object3D;
        const pos = new THREE.Vector3();
        const dir = new THREE.Vector3();
        camObj.getWorldPosition(pos);
        camObj.getWorldDirection(dir);

        const distance = 2.0; // ~2 ŸÖÿ™ÿ±
        dir.multiplyScalar(distance);
        pos.add(dir);
        // ÿßÿ¨ÿπŸÑ ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ ÿπŸÑŸâ ŸÖÿ≥ÿ™ŸàŸâ ÿßŸÑÿ±ÿ£ÿ≥ ÿ™ŸÇÿ±Ÿäÿ®ÿßŸã
        pos.y = 1.6;

        const itemId = 'placed_' + Date.now() + '_' + Math.random().toString(36).slice(2);

        let entity;
        if (media.type === 'image') {
            entity = document.createElement('a-plane');
            entity.setAttribute('src', '#' + media.id);
            entity.setAttribute('transparent', 'true');
            entity.setAttribute('width', '0.7');
            entity.setAttribute('height', '1.6');
        } else {
            // use a-plane with material=shader:flat and map the video texture
            entity = document.createElement('a-video');
            entity.setAttribute('src', '#' + media.id);
            entity.setAttribute('width', '0.9');
            entity.setAttribute('height', '1.6');
            entity.setAttribute('loop', 'true');
            entity.setAttribute('autoplay', 'true');
            // ensure video plays
            if (media.assetEl) {
                try { media.assetEl.muted = false; media.assetEl.loop = true; media.assetEl.play().catch(()=>{}); } catch(e){}
            }
        }

        entity.setAttribute('id', itemId);
        entity.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
        entity.setAttribute('shadow', 'cast: true; receive: false');

        // make interactive for controller raycasting and grabbing
        entity.classList.add('interactive');
        entity.setAttribute('data-media-id', media.id);

        // Component to always face camera (billboard)
        entity.setAttribute('billboard', '');

        // Component to allow simple drag move (mouse/touch)
        entity.setAttribute('draggable-plane', '');

        // When clicked, select for potential side-panel operations
        entity.addEventListener('click', (e2) => {
            e2.stopPropagation();
            highlightPlacedItem(itemId);
        });

        scene.appendChild(entity);

        placedItems.push({
            id: itemId,
            mediaId: media.id,
            entity,
            type: media.type,
            name: media.name
        });

        updateSidePanel();
        setStatus('ÿ™ŸÖ Ÿàÿ∂ÿπ ÿßŸÑÿπŸÜÿµÿ± ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©.', 'success');
        selectedMediaForPlacement = null;
    });

    // Additionally, allow controller "select" to place (some controllers send 'triggerdown' etc).
    // We'll listen to scene-level controller events and place at controller's forward ray intersection (or fixed distance).
    function setupControllerPlacement() {
        // Use controller entities in scene (rightHand / leftHand) and listen for 'gripdown' while a media selected to place
        ['rightHand', 'leftHand'].forEach(id => {
            const c = document.getElementById(id);
            if (!c) return;
            c.addEventListener('triggerdown', (ev) => {
                // if user selected a media from UI, place it where the controller is pointing
                if (!selectedMediaForPlacement) return;
                const media = mediaLibrary.find(m => m.id === selectedMediaForPlacement);
                if (!media) return;

                // find intersection with floor plane using controller's raycaster
                const raycasterComp = c.components.raycaster;
                let position = new THREE.Vector3();
                if (raycasterComp && raycasterComp.intersections && raycasterComp.intersections.length) {
                    const inter = raycasterComp.intersections[0];
                    if (inter && inter.point) {
                        position.copy(inter.point);
                    }
                } else {
                    // fallback: place a fixed distance forward from controller
                    const obj = c.object3D;
                    obj.getWorldPosition(position);
                    const dir = new THREE.Vector3();
                    obj.getWorldDirection(dir);
                    dir.multiplyScalar(1.6);
                    position.add(dir);
                    position.y = 1.6;
                }

                const itemId = 'placed_' + Date.now() + '_' + Math.random().toString(36).slice(2);

                let entity;
                if (media.type === 'image') {
                    entity = document.createElement('a-plane');
                    entity.setAttribute('src', '#' + media.id);
                    entity.setAttribute('transparent', 'true');
                    entity.setAttribute('width', '0.7');
                    entity.setAttribute('height', '1.6');
                } else {
                    entity = document.createElement('a-video');
                    entity.setAttribute('src', '#' + media.id);
                    entity.setAttribute('width', '0.9');
                    entity.setAttribute('height', '1.6');
                    entity.setAttribute('loop', 'true');
                    entity.setAttribute('autoplay', 'true');
                    if (media.assetEl) {
                        try { media.assetEl.muted = false; media.assetEl.loop = true; media.assetEl.play().catch(()=>{}); } catch(e){}
                    }
                }
                entity.setAttribute('id', itemId);
                entity.setAttribute('position', `${position.x} ${position.y} ${position.z}`);
                entity.setAttribute('shadow', 'cast: true; receive: false');
                entity.classList.add('interactive');
                entity.setAttribute('data-media-id', media.id);
                entity.setAttribute('billboard', '');
                entity.setAttribute('draggable-plane', '');
                entity.addEventListener('click', (e2) => { e2.stopPropagation(); highlightPlacedItem(itemId); });

                scene.appendChild(entity);
                placedItems.push({
                    id: itemId,
                    mediaId: media.id,
                    entity,
                    type: media.type,
                    name: media.name
                });
                updateSidePanel();
                setStatus('ÿ™ŸÖ Ÿàÿ∂ÿπ ÿßŸÑÿπŸÜÿµÿ± ÿπÿ®ÿ± ŸäÿØ VR.', 'success');
                selectedMediaForPlacement = null;
            });
        });
    }

    // Call once to wire up controller placement (entities exist in DOM)
    setupControllerPlacement();

    // ================================
    // BILLBOARD COMPONENT
    // ================================
    AFRAME.registerComponent('billboard', {
        tick: function () {
            const cameraEl = document.querySelector('#camera');
            if (!cameraEl) return;
            const cameraObj = cameraEl.object3D;
            const camPos = new THREE.Vector3();
            cameraObj.getWorldPosition(camPos);
            // Make plane face the camera in XZ-plane but keep upright
            const obj = this.el.object3D;
            const pos = new THREE.Vector3();
            obj.getWorldPosition(pos);
            const lookVec = new THREE.Vector3().subVectors(camPos, pos);
            lookVec.y = 0; // keep upright
            if (lookVec.lengthSq() === 0) return;
            obj.lookAt(new THREE.Vector3(pos.x + lookVec.x, pos.y, pos.z + lookVec.z));
        }
    });

    // ================================
    // DRAGGABLE COMPONENT (MOVE ON HORIZONTAL PLANE)
    // (keeps previous mouse/touch behavior)
    // ================================
    AFRAME.registerComponent('draggable-plane', {
        init: function () {
            this.dragging = false;
            this.startMouse = new THREE.Vector2();
            this.raycaster = new THREE.Raycaster();
            this.plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // horizontal plane
            this.offset = new THREE.Vector3();
            this.startPos = new THREE.Vector3();
            const el = this.el;

            el.addEventListener('mousedown', this.onMouseDown.bind(this));
            window.addEventListener('mousemove', this.onMouseMove.bind(this));
            window.addEventListener('mouseup', this.onMouseUp.bind(this));
            el.addEventListener('touchstart', this.onTouchStart.bind(this));
            window.addEventListener('touchmove', this.onTouchMove.bind(this));
            window.addEventListener('touchend', this.onTouchEnd.bind(this));
        },
        onMouseDown: function (evt) {
            evt.preventDefault();
            this.beginDrag(evt.clientX, evt.clientY);
        },
        onMouseMove: function (evt) {
            if (!this.dragging) return;
            evt.preventDefault();
            this.dragTo(evt.clientX, evt.clientY);
        },
        onMouseUp: function () {
            if (!this.dragging) return;
            this.dragging = false;
            setStatus('ÿ™ŸÖ ÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑÿπŸÜÿµÿ± ŸÅŸä ŸÖŸàŸÇÿπŸá ÿßŸÑÿ¨ÿØŸäÿØ.', 'success');
        },
        onTouchStart: function (evt) {
            if (!evt.touches || !evt.touches.length) return;
            const t = evt.touches[0];
            this.beginDrag(t.clientX, t.clientY);
        },
        onTouchMove: function (evt) {
            if (!this.dragging || !evt.touches || !evt.touches.length) return;
            const t = evt.touches[0];
            this.dragTo(t.clientX, t.clientY);
        },
        onTouchEnd: function () {
            if (!this.dragging) return;
            this.dragging = false;
            setStatus('ÿ™ŸÖ ÿ™ÿ´ÿ®Ÿäÿ™ ÿßŸÑÿπŸÜÿµÿ± ŸÅŸä ŸÖŸàŸÇÿπŸá ÿßŸÑÿ¨ÿØŸäÿØ.', 'success');
        },
        beginDrag: function (clientX, clientY) {
            this.dragging = true;
            this.startMouse.set(clientX, clientY);
            this.startPos.copy(this.el.object3D.position);
            setStatus('ÿßÿ≥ÿ≠ÿ® ŸÑÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑÿ¥ÿÆÿµ ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©.', 'info');
        },
        dragTo: function (clientX, clientY) {
            const cameraEl = document.querySelector('#camera');
            if (!cameraEl) return;
            const camera = cameraEl.getObject3D('camera');
            if (!camera) return;

            const mouse = new THREE.Vector2();
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            this.raycaster.setFromCamera(mouse, camera);

            const intersection = new THREE.Vector3();
            if (this.raycaster.ray.intersectPlane(this.plane, intersection)) {
                // keep the same height, move in x-z
                const pos = this.el.object3D.position;
                pos.set(intersection.x, pos.y, intersection.z);
            }
        }
    });

    // ================================
    // SIDE PANEL MANAGEMENT (LIST OF PLACED ITEMS)
    // ================================
    function updateSidePanel() {
        sideList.innerHTML = '';
        placedItems.forEach((item) => {
            const media = mediaLibrary.find(m => m.id === item.mediaId);
            if (!media) return;

            const row = document.createElement('div');
            row.className = 'side-item';
            row.dataset.id = item.id;

            const thumb = document.createElement('div');
            thumb.className = 'side-thumb';

            let mEl;
            if (item.type === 'image') {
                mEl = document.createElement('img');
            } else {
                mEl = document.createElement('video');
                mEl.autoplay = true;
                mEl.muted = true;
                mEl.loop = true;
                mEl.playsInline = true;
            }
            mEl.src = media.url;
            thumb.appendChild(mEl);

            const meta = document.createElement('div');
            meta.className = 'side-meta';

            const title = document.createElement('div');
            title.className = 'side-meta-title';
            title.textContent = media.name;
            meta.appendChild(title);

            const sub = document.createElement('div');
            sub.className = 'side-meta-sub';
            sub.textContent = item.type === 'image' ? 'ÿµŸàÿ±ÿ© ÿ´ÿßÿ®ÿ™ÿ©' : 'ŸÅŸäÿØŸäŸà ŸÅŸä ÿßŸÑÿ∫ÿ±ŸÅÿ©';
            meta.appendChild(sub);

            const actions = document.createElement('div');
            actions.className = 'side-actions';

            const btnFocus = document.createElement('button');
            btnFocus.className = 'pill-btn';
            btnFocus.textContent = 'üëÅÔ∏è ÿπÿ±ÿ∂';
            btnFocus.addEventListener('click', (ev) => {
                ev.stopPropagation();
                focusOnItem(item.id);
            });

            const btnDelete = document.createElement('button');
            btnDelete.className = 'pill-btn pill-btn-danger';
            btnDelete.textContent = 'ÿ≠ÿ∞ŸÅ';
            btnDelete.addEventListener('click', (ev) => {
                ev.stopPropagation();
                removePlacedItem(item.id);
            });

            actions.appendChild(btnFocus);
            actions.appendChild(btnDelete);

            row.appendChild(thumb);
            row.appendChild(meta);
            row.appendChild(actions);

            row.addEventListener('click', () => {
                highlightPlacedItem(item.id);
            });

            sideList.appendChild(row);
        });

        sideCount.textContent = placedItems.length + ' ÿπŸÜÿµÿ±';
    }

    function highlightPlacedItem(id) {
        placedItems.forEach((item) => {
            if (!item.entity) return;
            const isTarget = item.id === id;
            item.entity.setAttribute('material', 'opacity: 1;');
            if (isTarget) {
                item.entity.setAttribute('animation__pulse', {
                    property: 'scale',
                    from: '1 1 1',
                    to: '1.05 1.05 1.05',
                    dur: 200,
                    dir: 'alternate',
                    loop: 3
                });
            }
        });
        setStatus('ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿπŸÜÿµÿ±ÿå ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ≠ÿ±ŸäŸÉŸá ÿ®ÿßŸÑŸÖÿßŸàÿ≥/ÿßŸÑŸÑŸÖÿ≥ ÿ£Ÿà ÿßŸÑÿ•ŸÖÿ≥ÿßŸÉ ÿ®Ÿá ÿ®ŸäÿØ VR.', 'info');
    }

    function focusOnItem(id) {
        const item = placedItems.find(p => p.id === id);
        if (!item || !item.entity) return;

        const cameraEl = document.getElementById('camera');
        if (!cameraEl) return;

        // Move camera rig to look at item (in non-AR mode mainly)
        const rig = document.getElementById('rig');
        const entPos = new THREE.Vector3();
        item.entity.object3D.getWorldPosition(entPos);

        // Place camera rig a bit behind original position and look at the entity
        rig.object3D.position.set(entPos.x, rig.object3D.position.y, entPos.z + 2.0);

        const camObj = cameraEl.object3D;
        camObj.lookAt(entPos);
        setStatus('ÿ™ŸÖ ÿ™ÿ≠ÿ±ŸäŸÉ ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß ŸÑŸÖÿ¥ÿßŸáÿØÿ© ÿßŸÑÿπŸÜÿµÿ±.', 'success');
    }

    function removePlacedItem(id) {
        const idx = placedItems.findIndex(p => p.id === id);
        if (idx < 0) return;
        const item = placedItems[idx];
        if (item.entity && item.entity.parentNode) {
            item.entity.parentNode.removeChild(item.entity);
        }
        placedItems.splice(idx, 1);
        updateSidePanel();
        setStatus('ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿπŸÜÿµÿ± ŸÖŸÜ ÿßŸÑÿ∫ÿ±ŸÅÿ©.', 'success');
    }

    // ================================
    // RESET ALL
    // ================================
    btnResetAll.addEventListener('click', () => {
        if (!confirm('ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØ ŸÖŸÜ ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÖŸÜ ÿßŸÑÿ∫ÿ±ŸÅÿ©ÿü')) return;
        // Remove placed items
        while (placedItems.length) {
            const item = placedItems.pop();
            if (item.entity && item.entity.parentNode) {
                item.entity.parentNode.removeChild(item.entity);
            }
        }
        updateSidePanel();
        setStatus('ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÖŸÜ ÿßŸÑÿ∫ÿ±ŸÅÿ©.', 'success');
    });

    // ================================
    // INITIAL STATUS
    // ================================
    window.addEventListener('load', () => {
        setStatus('ÿ¨ÿßŸáÿ≤ÿå ÿßÿ®ÿØÿ£ ÿ®ÿ±ŸÅÿπ ÿµŸàÿ±ÿ© ÿ£Ÿà ŸÅŸäÿØŸäŸà ÿ´ŸÖ ÿßÿØÿÆŸÑ Ÿàÿ∂ÿπ AR.', 'info');
        // enable controllers wiring (in case they were present)
        enableControllersForSession();
    });

</script>
</body>
</html>
